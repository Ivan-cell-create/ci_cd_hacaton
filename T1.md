# Хакатон от Т1 - Self-Deploy: CI/CD без DevOps

## Первичные требования: 

Автоматизируйте генерацию CI/CD пайплайнов по анализу структуры Git-репозитория. Необходимо разработать скрипт, который клонирует репозиторий, анализирует файлы конфигурации, зависимости и код, определяет стек технологий и генерирует YAML-шаблоны для Jenkins/GitLab. Этот инструмент должен поддерживать сборку, тестирование и развёртывание, а также должен быть совместим с разными языками и фреймворками.


## Основные задачи скрипта `auto-cicd-gen` (MVP)

| # | Задача                     | Что делает                                      | Как реализуем (1 строчка)                     |
|---|----------------------------|--------------------------------------------------|-----------------------------------------------|
| 1 | **Принять репозиторий**    | URL или локальная папка                          | `repo = sys.argv[1]`                          |
| 2 | **Склонировать в temp**    | Только если URL                                  | `git clone --depth 1`                         |
| 3 | **Найти ключевые файлы**   | `package.json`, `requirements.txt`, `Dockerfile` и т.д. | `Path.rglob()`                                |
| 4 | **Определить стек**        | Python / Node.js / Docker / Unknown              | простые `if exists()`                         |
| 5 | **Выбрать шаблон**         | В зависимости от стека                           | словарь шаблонов                              |
| 6 | **Сгенерировать `.gitlab-ci.yml`** | Подставить переменные и вывести          | Jinja2 и

## Алгоритм

```md
┌─────────────────────┐
│ 1. Принять источник │ - Локальный (путь) или ссылкой на репу
└─────────────────────┘
         ↓
┌──────────────────────┐
│ 2. Клонировать в /tmp│
└──────────────────────┘
         ↓
┌────────────────────┐
│ 3. Найти ВСЕ файлы │ - Path.rglob("*")
└────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 4. Применить детекторы по приоритету │ - список из 11 правил
└──────────────────────────────────────┘
         ↓
┌────────────────────┐
│ 5. Выбрать шаблон  │ - dict: "docker" - "docker.yml.j2"
└────────────────────┘
         ↓
┌────────────────────┐
│ 6. Собрать контекст│ - build_cmd, test_cmd, artifact, docker=True?
└────────────────────┘
         ↓
┌──────────────────────┐
│ 7. Отрендерить Jinja2│ - с защитой от пустых значений
└──────────────────────┘
         ↓
┌────────────────────┐
│ 8. Записать файл   │ - .gitlab-ci.yml или Jenkinsfile
└────────────────────┘
         ↓
┌────────────────────┐
│ 9. Вывести успех   │
└────────────────────┘
```

### Объяснения пунктов: 

| Шаг | Что делаем | Почему именно так | Пример |
|-----|------------|-------------------|--------|
| **1** | Берём то, что ввёл пользователь | Чтобы работать и локально, и с любым GitHub/GitLab | `./auto-cicd-gen.py ./my-app` <br> `./auto-cicd-gen.py https://github.com/tiangolo/fastapi` |
| **2** | Если это ссылка — быстро клонируем в временную папку | Не мусорим на диске, удаляется само после работы | `git clone --depth 1` - только последний коммит |
| **3** | Одной строчкой собираем список всех файлов проекта | Самый быстрый способ (< 0.1 сек даже на больших репо) | `files = list(repo_path.rglob("*"))` |
| **4** | Идём по списку правил сверху вниз и ищем ключевые файлы | Приоритет из ТЗ: **Dockerfile важнее всего** | Если есть `Dockerfile` - сразу выбираем Docker-шаблон, остальное игнорируем |
| **5** | Берём готовый `.j2` шаблон под найденный стек | Не пишем YAML вручную — просто подставляем | `templates/node.yml.j2`, `templates/python-poetry.yml.j2` |
| **6** | Собираем словарь с нужными командами и флагами | Чтобы шаблон знал, что подставить | ```python<br>{'test_cmd': 'pytest --cov',<br>'build_cmd': 'poetry build',<br>'has_docker': True,<br>'project_name': 'fastapi'}<br>``` |
| **7** | Заполняем шаблон как письмо с пустыми местами | Jinja2 + `{% if %}` - пайплайн **никогда не падает** | ```jinja2<br>{% if test_cmd %}<br>- {{ test_cmd }}<br>{% else %}<br>- echo "no tests"<br>{% endif %}<br>``` |
| **8** | Пишем готовый `.gitlab-ci.yml` прямо в корень проекта | Один клик — и можно сразу `git push` | Автоматически попадёт в коммит |
| **9** | Пишем в терминал, что всё готово | Конечный вывод (информормированность юзеров) | `Генерация завершена!`<br>`Обнаружен Python + Docker - docker + poetry шаблон` |

## Приоритетность 

| Приоритет | Файл / паттерн | Что обнаруживает | Почему выше остальных |
|----------|----------------|------------------|-----------------------|
| **1** | `Dockerfile` | Любой проект с Docker | **Docker перекрывает всё** — если есть Dockerfile, значит уже есть готовый образ. Никакой другой сборки не нужно. |
| **2** | `package.json` | Node.js / TypeScript / JS | Самый популярный стек на GitHub. `npm/yarn/pnpm` — единый способ установки. |
| **3** | `pyproject.toml` | Python (Poetry, pdm, hatch, flit) | Современный стандарт Python ≥3.11. Poetry — №1 в 2025 году. |
| **4** | `requirements.txt` | Python (pip) | Классика, до сих пор в 60 % репо. Но ниже `pyproject.toml`. |
| **5** | `Pipfile` / `Pipfile.lock` | Python (Pipenv) | Редко, но встречается. Ниже pip, потому что устаревает. |
| **6** | `pom.xml` | Java / Kotlin (Maven) | Maven — стандарт enterprise. |
| **7** | `build.gradle` / `build.gradle.kts` | Java / Kotlin / Groovy (Gradle) | Gradle популярнее Maven в новых проектах. |
| **8** | `go.mod` + `go.sum` | Go | Go-модули — единственный официальный способ. |
| **9** | `Cargo.toml` + `Cargo.lock` | Rust | Cargo — как `package.json` для Rust. |
| **10** | `composer.json` + `composer.lock` | PHP | Composer — единственный нормальный менеджер PHP. |
| **11** | **Отсутствие всех выше** | Неизвестный стек | Fallback-шаблон с `alpine:latest` и сообщением “Добавьте Dockerfile” |

## Момент безопасности по поводу .env


| Шаг | Что делаем | Почему именно так | Пример вывода в терминале / файле |
|-----|------------|-------------------|-----------------------------------|
| **1** | Ищем все файлы, начинающиеся на `.env` (кроме `.env.example`) | Новички коммитят `.env` в 80 % случаев. Это **самая частая уязвимость** на GitLab. Мы ловим её на лету. | `Найдено 2 .env файла! Удалите их из репозитория!` |
| **2** | Если есть `.env.example` — читаем его и извлекаем ключи | Это **шаблон переменных**, который разработчик и так хотел показать. Мы просто автоматизируем рутину. | `Обнаружен .env.example - добавляем подсказки в .gitlab-ci.yml` |
| **3** | Добавляем в начало `.gitlab-ci.yml` блок с предупреждением и инструкцией | Жюри видит, что ты не просто генеришь пайплайн — ты **учишь безопасности**. Это production-ready подход. |```yaml<br># ==============================================================================<br># ВНИМАНИЕ: Обнаружены .env файлы! УДАЛИТЕ ИХ ИЗ РЕПОЗИТОРИЯ!<br># Переменные ниже — из вашего .env.example<br># Добавьте их в GitLab - Settings - CI/CD - Variables (Masked + Protected если нужно)<br># ==============================================================================<br>variables:<br>  DATABASE_URL: "postgresql://user:pass@localhost/db"   # ← скопируйте в GitLab<br>  SECRET_KEY: "super-secret-change-me"                # ← обязательно поменяйте!<br>  DEBUG: "false"                                      # ← только для продакшена<br>``` |


## Что анализирует скрипт auto-cicd-gen (MVP)

Скрипт автоматически сканирует репозиторий и принимает решения **только на основе наличия файлов**.  
Никаких тяжёлых парсеров, AST или AI — всё максимально быстро и надёжно.

| Приоритет | Файл / паттерн                     | Что обнаруживает                          | Как используется в пайплайне                              |
|-----------|------------------------------------|-------------------------------------------|-----------------------------------------------------------|
| 1         | `Dockerfile`                       | Проект с Docker                           | - `docker` шаблон (build + push в GitLab Registry)        |
| 2         | `package.json`                     | Node.js / JavaScript / TypeScript         | - `node` шаблон (npm ci - test - build - artifacts)       |
| 3         | `requirements.txt`                 | Python (pip)                              | - `python` шаблон (pip install - pytest + coverage)       |
| 4         | `pyproject.toml`                   | Python (Poetry / pdm / hatch / flit)      | - `python` шаблон (poetry install - pytest + build wheel) |
| 5         | `Pipfile` / `Pipfile.lock`         | Python (Pipenv)                           | - `python` шаблон (pipenv install --deploy - test)        |
| 6         | `pom.xml`                          | Java / Kotlin (Maven)                     | - `java` шаблон (mvn verify - package - JAR artifact)     |
| 7         | `build.gradle` / `build.gradle.kts`| Java / Kotlin / Groovy (Gradle)           | - `gradle` шаблон (./gradlew test build - JAR/WAR)        |
| 8         | `go.mod` + `go.sum`                | Go (Modules)                              | - `go` шаблон (go test -v ./... - go build - binary)      |
| 9         | `Cargo.toml` + `Cargo.lock`        | Rust (Cargo)                              | - `rust` шаблон (cargo test --all - cargo build --release)|
| 10        | `composer.json` + `composer.lock`  | PHP (Composer)                            | - `php` шаблон (composer install - phpunit - artifact)    |
| —         | **Отсутствие всех выше**           | Неизвестный стек                          | - fallback-шаблон с `alpine` и предупреждением            |         |

## Пример использования
```bash
# Локальный проект
./auto-cicd-gen.py ./my-fastapi-app

# Удалённый репозиторий
./auto-cicd-gen.py https://github.com/tiangolo/fastapi.git
```

## Как будет выглядить структура проекта 

```md 
auto-cicd-gen/
├── auto-cicd-gen.py        # точка входа в нашем приложении
├── templates/              # шаблоны
|   ├──_env_warning.yml.j2  # блок с .env предупреждением
│   ├── docker.yml.j2
│   ├── node.yml.j2
│   ├── python-poetry.yml.j2
│   ├── fallback.yml.j2
│   └── java-gradle.yml.j2
├── detectors.py           # отдельный файл с приоритетами
├── utils.py               # .env парсер + вспомогательные функции 
└── README.md              # итоговая документация по срикпту 
```
### Разбор auto-cicd-gen.py (по содержимому)

```python
#!/usr/bin/env python3
import sys, tempfile, shutil, git, atexit, logging, argparse
# sys — для argv
# tempfile — безопасные временные папки
# shutil — удаление кеша и очистка
# git — клонирование репозиториев
# atexit — гарантированная очистка при выходе
# logging — журнал действий (auto-cicd-gen.log)
# argparse — красивые флаги (--stdout, --force, --dry-run, --s3-cache)

from pathlib import Path
# Path — работа с путями (rglob, resolve, write_text)

from jinja2 import Environment, FileSystemLoader
# Jinja2 — рендер YAML-шаблонов с переменными
# FileSystemLoader("templates") — берёт .j2 файлы из папки templates

from detectors import detect_stack
# detect_stack() - определяет стек по приоритетам (Dockerfile > uv > poetry > pip и т.д.)

from utils import find_env_files, parse_env_example, get_repo_name, setup_logging
# find_env_files() - ловит .env утечки и читает .env.example
# parse_env_example() - превращает .env.example в словарь variables
# get_repo_name() - извлекает имя проекта из URL или пути
# setup_logging() - включает логи в файл + терминал

from cache import setup_cache_policy
# setup_cache_policy() - генерирует кеш-блок для GitLab CI (локальный + S3)

# ВХОДНЫЕ ДАННЫЕ
# sys.argv[1] - строка:
# • https://github.com/user/repo.git
# • git@github.com:user/repo.git
# • ./my-project
# • /home/user/app
# Дополнительно (через argparse):
# --stdout   - вывести .gitlab-ci.yml в терминал
# --force    - перезаписать существующий файл без вопроса
# --dry-run  - только показать, не писать на диск
# --s3-cache - URL S3-совместимого хранилища для распределённого кеша

# ВЫХОДНЫЕ ДАННЫЕ
# 1. Файл .gitlab-ci.yml в корне проекта (или в stdout)
# 2. Журнал действий - auto-cicd-gen.log
# 3. Код возврата: 0 = ок, 1 = ошибка, 2 = .env утечка

def main():
# 0. ЛОГИРОВАНИЕ — с самого начала
#    - auto-cicd-gen.log + вывод в терминал
#    - все шаги, ошибки, предупреждения сохраняются
#    - даже при Ctrl+C или падении — журнал остаётся

# 1. Принять аргумент
#    - используем argparse для надёжного парсинга
#    - проверяем, что source не пустой
#    - если пусто - ругаемся и выходим с кодом 1

# 2. Клонировать или взять локальный путь
#    - если URL (http или git@) - git clone --depth 1 в /tmp/auto-cicd-XXXX
#    - если путь - Path(source).resolve()
#    - результат: repo_path = абсолютный путь к корню проекта

# 2.1 АТОМАРНОСТЬ: очистка при старте
#    - удаляем .cicd-cache/ (если был)
#    - предотвращаем накопление мусора при падении или Ctrl+C
#    - гарантируем чистое состояние при каждом запуске

# 3. Собрать все файлы
#    - files = [p for p in repo_path.rglob("*") if p.is_file()]
#    - быстро: < 0.1 сек даже на 100к файлов

# 4. detect_stack() - dict
#    - {"stack": "docker", "template": "docker.yml.j2", "context": {...}}
#    - внутри: приоритеты, Dockerfile важнее всего
#    - uv - после poetry, выше pip

# 5. find_env_files() - три вещи сразу
#    - опасные .env файлы (удалить!)
#    - найден ли .env.example
#    - готовый словарь variables: {"DB_URL": "postgres://..."}

# 5.1 КЕШ: политика под стек
#    - setup_cache_policy(stack, s3_endpoint)
#    - Docker - cache-from/to в registry
#    - Python (uv) - .cicd-cache/uv/
#    - Node.js - node_modules/ + .npm
#    - S3 - distributed cache (если --s3-cache)

# 6. Загрузить Jinja2 env
#    - Environment(loader=FileSystemLoader("templates"))
#    - автоэскейп выключен (YAML не HTML)
#    - keep_trailing_newline=True - сохраняем переносы

# 7. Отрендерить два шаблона
#    - сначала _env_warning.yml.j2 (если есть .env или example)
#    - потом основной шаблон (docker.yml.j2, node.yml.j2 и т.д.)
#    - всё в одну строку - готовый YAML

# 8. Записать .gitlab-ci.yml
#    - если --stdout - print(yaml_text)
#    - иначе - (repo_path / ".gitlab-ci.yml").write_text(yaml_text)
#    - если файл есть и нет --force - спрашиваем "перезаписать? (y/n)"

# 9. Вывести обратную связь
#    - rich или print с цветами:
#      Генерация завершена за 1.7 сек
#      Стек: Docker + Python (uv)
#      Кеш: локальный + S3
#      ВНИМАНИЕ: Найдено 2 .env файла! УДАЛИТЕ!
#      Переменные добавлены в variables:
#      Файл записан: /path/to/.gitlab-ci.yml
#      git add .gitlab-ci.yml && git commit -m "ci: auto-cicd-gen" && git push
```

### Разбор detectors.py (по содержимому)

```python 
# detectors.py
from pathlib import Path
from typing import Dict, List, Any

# ВХОДНЫЕ ДАННЫЕ
# detect_stack(repo_path: Path) - один аргумент:
#   • repo_path — абсолютный Path до корня репозитория (уже склонированного или локального)
#   • внутри автоматически: list(repo_path.rglob("*")) - все файлы

# ВЫХОДНЫЕ ДАННЫЕ
# detect_stack() возвращает ровно один dict:
# {
#     "stack": str,          # "docker" | "node" | "python-poetry" | "unknown" и т.д.
#     "template": str,       # имя файла .j2 из templates/ (например "docker.yml.j2")
#     "context": Dict[str, Any]  # всё, что нужно Jinja2:
#         ├── "project_name": str
#         ├── "has_docker": bool
#         ├── "install_cmd": str | None
#         ├── "test_cmd": str | None
#         ├── "build_cmd": str | None
#         ├── "artifact_path": str | None
#         ├── "docker_tag": str
#         └── любые дополнительные флаги (has_tests, use_cache и т.д.)
# }

# 1. Список приоритетов — кортеж (stack_name, template, detector_func)
# 2. Детекторы — лямбды, проверяют наличие файлов и содержимое
# 3. build_context() — формирует словарь с командами под стек
# 4. detect_stack() — проходит по приоритетам сверху вниз
# 5. Dockerfile всегда первый — перекрывает всё
# 6. Поддержка 11 стеков + unknown в конце
# 7. Возвращает stack, template и context для Jinja2
# 8. Один вызов из main.py — вся логика здесь
# 9. Никаких внешних зависимостей — чистый pathlib
```

### Разбор utils.py (по содержимому)

```python
# utils.py
from pathlib import Path
from typing import Tuple, List, Dict, Optional

# ВХОДНЫЕ ДАННЫЕ
# 1. find_env_files(repo_path: Path) - просто путь к папке проекта
# 2. parse_env_example(path: Optional[Path]) - путь к .env.example или None
# 3. clean_temp_dir(temp_dir: Path) - путь к временной папке
# 4. get_repo_name(source: str) - URL или локальный путь (строка)

# ВЫХОДНЫЕ ДАННЫЕ
# find_env_files() - возвращает кортеж из трёх штук:
# (
#     danger: List[Path],        # все .env, .env.local и т.п. — то, что нельзя коммитить
#     example: Optional[Path],   # найденный .env.example или None
#     variables: Dict[str, str]  # готовый словарь: {"SECRET_KEY": "change-me", "DB_URL": "..."}
# )

# parse_env_example() - Dict[str, str]
#    • пропускает строки с #
#    • пропускает пустые строки
#    • берёт только KEY=VALUE
#    • убирает " и ' вокруг значения

# get_repo_name() - str
#    • из https://github.com/user/my-app.git - "my-app"
#    • из /home/user/projects/cool-site - "cool-site"
#    • если не понял - "unknown-repo"

# clean_temp_dir() - ничего не возвращает, просто удаляет папку и не падает

# 1. Находит все опасные .env файлы - кричит в терминал "УДАЛИ ЭТО!"
# 2. Находит .env.example - читает его как шаблон переменных
# 3. Делает готовый блок variables: для GitLab CI
# 4. Узнаёт имя проекта — для docker-тегов и артефактов
# 5. Удаляет временную папку даже если юзер нажал Ctrl+C
# 6. Ловит .env.local, .env.prod, .env.test — всё, что не .example
# 7. При выводе прячет пароли (если в значении есть pass/secret/key)
# 8. Один вызов из main.py - сразу всё про .env
# 9. Работает без pip install — только стандартная библиотека
```
